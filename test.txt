from functools import wraps
import time

class ConflictError(Exception):
    def __init__(self, remaining):
        super().__init__("Conflict detected in bulk update")
        self.remaining = remaining

def retry_conflicts(max_retries=3, delay=0.05):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0

            while True:
                try:
                    return func(*args, **kwargs)
                
                except ConflictError as e:
                    attempts += 1
                    remaining = e.remaining

                    if attempts > max_retries:
                        raise  # give up after retries
                    
                    # retry only for remaining trades
                    kwargs["trades"] = remaining
                    time.sleep(delay)

        return wrapper
    return decorator



@retry_conflicts(max_retries=3)
def update_trades(self, trades):
    bulk_ops = []

    for t in trades:
        bulk_ops.append(
            UpdateOne(
                {"tradeId": t.tradeId, "version": t.version},
                {"$set": t.to_dict()}
            )
        )

    result = self.collection.bulk_write(bulk_ops, ordered=False)

    # Example conflict detection
    if result.modified_count != len(trades):
        success_ids = {op._filter["tradeId"] for op in bulk_ops if op._filter.get("tradeId")}
        failed = [t for t in trades if t.tradeId not in success_ids]
        raise ConflictError(failed)

    return result
